// Generated by CoffeeScript 1.9.0
(function() {
  var BlobDetector;

  BlobDetector = (function() {
    function BlobDetector(_at_cv, _at_canvas) {
      this.cv = _at_cv;
      this.canvas = _at_canvas;
      this.ctx = this.canvas.getContext('2d');
    }

    BlobDetector.prototype.process = function() {
      var imageData, r1, r2, r3;
      imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      r1 = this.getDiffImage(imageData);
      r2 = this.getBlocks(r1);
      r3 = this.drawBlobs(imageData);
      return [r1, r2, r3];
    };

    BlobDetector.prototype.getDiffImage = function(imageData) {
      var blend1, blend2, destPt, finalBlend, finalImg, originalImageData, rect, srcRect, tmp, weight;
      originalImageData = imageData;
      this.ctx.translate(2, 0);
      tmp = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      blend1 = this.cv.blend(tmp, originalImageData, 'difference');
      destPt = {
        x: 0,
        y: 0
      };
      srcRect = {
        x: 2,
        y: 0,
        w: 2,
        h: imageData.height
      };
      this.cv.copyPixels(originalImageData, srcRect, blend1, destPt);
      this.ctx.translate(-2, 2);
      tmp = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      blend2 = this.cv.blend(tmp, originalImageData, 'difference');
      srcRect = {
        x: 0,
        y: 2,
        w: imageData.width,
        h: 2
      };
      this.cv.copyPixels(originalImageData, srcRect, blend2, destPt);
      rect = {
        x: 0,
        y: 0,
        w: 2,
        h: imageData.height
      };
      finalBlend = this.cv.blend(blend1, blend2, 'add');
      weight = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
      finalImg = this.cv.convolute(finalBlend, weight, true);
      finalImg = this.cv.threshold(finalImg, "<", 10, 0);
      finalImg = this.cv.threshold(finalImg, "!=", 233, 255);
      return finalImg;
    };

    BlobDetector.prototype.getBlocks = function(imageData) {
      var i, o, r, rect1, rect2, size, x, y, _i, _j, _ref, _ref1, _ref2;
      this.blocks = [];
      r = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      rect1 = this.getColorBoundsRect(r, 'ffffff', 'ff00ff');
      if (rect1 == null) {
        return;
      }
      x = rect1.x;
      for (y = _i = _ref = rect1.y, _ref1 = rect1.y + rect1.height - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        if (r.data[(y * r.width * 4) + x * 4] === 255 && r.data[(y * r.width * 4) + x * 4 + 1] === 255 && r.data[(y * r.width * 4) + x * 4 + 2] === 255) {
          ctx.fillStyle = "rgb(127,127,127)";
          ctx.fillRect(x, y, 1, 1);
          rect2 = this.getColorBoundsRect(r, 'ffffff', 'ff00ff');
          size = rect2.width * rect2.height;
          if (size > 300) {
            o = {
              size: size,
              rect: rect2,
              bmpd: this.ctx.getImageData(o.rect.width, o.rect.height)
            };
            r.imageData = o.bmpd.data(r, o.rect, this.blocks.push(o));
          }
        }
      }
      ctx.fillStyle = "00ff00";
      ctx.fillRect(x, y, 1, 1);
      for (i = _j = 0, _ref2 = this.blocks.length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
        this.ctx.strokeStyle = "00ff00";
        g.drawRect(this.blocks[i].rect.x, this.blocks[i].rect.y, this.blocks[i].rect.width, this.blocks[i].rect.height);
      }
      r.draw(sp);
      return r;
    };

    BlobDetector.prototype.drawBlobs = function(imageData) {
      var b, i, j, pts, r, x, y, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      r = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      for (i = _i = 0, _ref = this.blocks.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        pts = [];
        b = this.blocks[i];
        for (y = _j = 0, _ref1 = b.rect.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          for (x = _k = 0, _ref2 = b.rect.width - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = 0 <= _ref2 ? ++_k : --_k) {
            if (b.bmpd.getPixel(x, y) === 0xff00ff) {
              pts.push({
                x: x,
                y: y
              });
              break;
            }
          }
        }
        for (y = _l = _ref3 = b.rect.height - 1; _l >= 0; y = _l += -5) {
          for (x = _m = _ref4 = b.rect.width - 1; _ref4 <= 0 ? _m <= 0 : _m >= 0; x = _ref4 <= 0 ? ++_m : --_m) {
            if (b.bmpd.getPixel(x, y) === 0xff00ff) {
              pts.push({
                x: x,
                y: y
              });
              break;
            }
          }
        }
      }
      this.ctx.save();
      this.ctx.fillStyle = "ff0000";
      this.ctx.lineWidth = 0.2;
      this.ctx.strokeStyle = "ff0000";
      this.ctx.beginPath();
      for (j = _n = 0, _ref5 = pts.length - 1; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
        if (j === 0) {
          this.ctx.moveTo(b.rect.x + mid1.x, b.rect.y + mid1.y);
        }
        this.ctx.quadraticCurveTo(b.rect.x + pts[(j + 1) % pts.length].x, b.rect.y + pts[(j + 1) % pts.length].y, b.rect.x + mid2.x, b.rect.y + mid2.y);
      }
      this.ctx.fill();
      this.ctx.restore();
      return r;
    };

    BlobDetector.prototype.getColorBoundsRect = function(imageData, minThreshold, maxThreshold) {
      var xMax, xMin, yMax, yMin;
      xMin = yMin = xMax = yMax = 0;
      this.ctx.save();
      this.ctx.strokeStyle = "ff0000";
      this.ctx.strokeRect(xMin, yMin, xMax - xMin, yMax - yMin);
      return this.ctx.restore();
    };

    BlobDetector.prototype.getPixelColor = function(x, y) {
      var hsl, p, str;
      p = this.ctx.getImageData(x, y, 1, 1).data;
      hsl = this.cv.rgbToHsl(p[0], p[1], p[2]);
      str = 'h:' + hsl[0] + ' s:' + hsl[1] + ' l:' + hsl[2];
      return str;
    };

    BlobDetector.prototype.blend = function(lastImageData, sourceData, ctx, ctx2) {
      var average, blendedData, height, i, len, width, zone, _i;
      width = this.canvas.width;
      height = this.canvas.height;
      blendedData = this.ctx.createImageData(width, height);
      this.differenceAccuracy(blendedData.data, sourceData.data, lastImageData.data);
      if (ctx != null) {
        ctx.putImageData(blendedData, 0, 0);
      }
      zone = ctx.getImageData(0, 0, 50, 50);
      if (ctx2 != null) {
        ctx2.putImageData(zone, 0, 0);
      }
      average = 0;
      len = zone.data.length - 4;
      for (i = _i = 0; _i <= len; i = _i += 4) {
        average += (zone.data[i] + zone.data[i + 1] + zone.data[i + 2]) / 3;
      }
      average = Math.round(average / (zone.data.length * 0.25));
      if (average > 150) {
        return true;
      } else {
        return false;
      }
    };

    BlobDetector.prototype.differenceAccuracy = function(target, data1, data2) {
      var average1, average2, diff, i, len, _i, _results;
      if (data1.length !== data2.length) {
        return null;
      }
      len = data1.length - 4;
      _results = [];
      for (i = _i = 0; _i <= len; i = _i += 4) {
        average1 = (data1[i] + data1[i + 1] + data1[i + 2]) / 3;
        average2 = (data2[i] + data2[i + 1] + data2[i + 2]) / 3;
        diff = this.threshold(this.fastAbs(average1 - average2));
        target[i] = diff * 255;
        target[i + 1] = diff * 255;
        target[i + 2] = diff * 255;
        _results.push(target[i + 3] = 255);
      }
      return _results;
    };

    BlobDetector.prototype.fastAbs = function(value) {
      return (value ^ (value >> 31)) - (value >> 31);
    };

    BlobDetector.prototype.threshold = function(value) {
      var _ref;
      return (_ref = value > 0x15) != null ? _ref : {
        0xFF: 0
      };
    };

    BlobDetector.prototype.copyPixels = function(ctx, srcRect, destPt) {
      return ctx.putImageData(srcRect, destPt.x, destPt.y);
    };

    BlobDetector.prototype.detect = function(ctx) {
      var bhmax, bhmin, bmap, bweight, data, frame, ghmax, ghmin, gmap, gweight, h, height, hsl, i, l, len, map, maxx, maxy, minx, miny, redhmax, redhmin, redmap, redweight, rhmax, rhmin, rmap, rweight, s, spot, type, width, _i;
      minx = this.canvas.width;
      miny = this.canvas.height;
      maxx = maxy = 0;
      width = this.canvas.width;
      height = this.canvas.height;
      redhmin = 320;
      redhmax = 360;
      redweight = 0;
      redmap = [];
      rhmin = 35;
      rhmax = 50;
      rweight = 0;
      rmap = [];
      bhmin = 185;
      bhmax = 210;
      bweight = 0;
      bmap = [];
      ghmin = 90;
      ghmax = 105;
      gweight = 0;
      gmap = [];
      this.ctx.save();
      frame = this.ctx.getImageData(0, 0, width, height);
      this.ctx.restore();
      data = frame.data;
      len = frame.data.length - 4;
      for (i = _i = 0; _i <= len; i = _i += 4) {
        hsl = this.cv.rgbToHsl(data[i + 0], data[i + 1], data[i + 2]);
        h = hsl[0];
        s = hsl[1];
        l = hsl[2];
        if (h >= rhmin && h <= rhmax && s >= 20 && s <= 90 && l >= 20 && l <= 90) {
          rmap.push(1);
          rweight++;
        } else {
          rmap.push(0);
        }
        if (h >= bhmin && h <= bhmax && s >= 20 && s <= 90 && l >= 20 && l <= 90) {
          bmap.push(1);
          bweight++;
        } else {
          bmap.push(0);
        }
        if (h >= ghmin && h <= ghmax && s >= 20 && s <= 90 && l >= 20 && l <= 90) {
          gmap.push(1);
          gweight++;
        } else {
          gmap.push(0);
        }
        if (h >= redhmin && h <= redhmax && s >= 20 && s <= 90 && l >= 20 && l <= 90) {
          redmap.push(1);
          redweight++;
        } else {
          redmap.push(0);
        }
      }
      if (redweight > rweight && redweight > gweight && redweight > bweight) {
        type = 'mountain';
        map = redmap;
      } else {
        if (rweight > bweight) {
          if (rweight > gweight) {
            type = 'sand';
            map = rmap;
          } else {
            if (gweight > bweight) {
              type = 'grass';
              map = gmap;
            } else {
              type = 'water';
              map = bmap;
            }
          }
        } else {
          if (gweight > bweight) {
            type = 'grass';
            map = gmap;
          } else {
            type = 'water';
            map = bmap;
          }
        }
      }
      spot = this.scoreMap(map);
      if (ctx != null) {
        ctx.putImageData(frame, 0, 0);
      }
      return {
        type: type,
        bounds: spot
      };
    };

    BlobDetector.prototype.scoreMap = function(map) {
      var height, i, index, j, pos, target, val, width, _i, _j, _ref, _ref1;
      width = this.canvas.width;
      height = this.canvas.height;
      val = 0;
      target = 0;
      pos = {
        x: 0,
        y: 0
      };
      for (j = _i = 5, _ref = height - 6; 5 <= _ref ? _i <= _ref : _i >= _ref; j = 5 <= _ref ? ++_i : --_i) {
        for (i = _j = 5, _ref1 = width - 6; 5 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 5 <= _ref1 ? ++_j : --_j) {
          index = this.cv.XYToIndex(width, i - 3, j - 3) / 4;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          index += width;
          val += map[index] + map[index++] + map[index++] + map[index++] + map[index++] + map[index++];
          if (val > target) {
            pos = {
              x: i,
              y: j
            };
            target = val;
          }
          val = 0;
        }
      }
      return pos;
    };

    return BlobDetector;

  })();

  if (typeof module !== 'undefined' && module.exports) {
    exports.BlobDetector = BlobDetector;
  } else {
    window.BlobDetector = BlobDetector;
  }

}).call(this);
